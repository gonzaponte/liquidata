Most names are subject to change, but the structure is mostly there.

The biggest thing that is missing is picking and setting of components of a
namespace flowing through the pipes. Remember that the idea is that this must be
decoupled from the components themselves, and implemented in an orthogonal and
reusable way. The picking is trivial. The setting is more complicated because
components may not yield exactly one item for each item they receive: filter is
an obvious example, and FlatMap (available in the implementation) is another. If
you can't think of a use for FlatMap, consider a stream of filenames, being
expanded into a stream of events in those files: each file sent in results in an
arbitrary number of events coming out. Anyway, I need to think more about the
variations on this theme and what the best interface would be, but I am
confident that something can be done.

In the meantime, I'd like you to have a look at what I have produced so far.
Here is an outline of how it works. Remember, the names appearing in the API are
not fixed at all.

The module name is currently 'reboot'. This will definitely change.

The file reboot.py is all you should need to try it out, as there are no
dependencies apart from standard modules.

Many names are currently capitalized (Network, Map, Sink, ...). This is likely
to change.

OK, here goes:

==================================================

The first test in reboot_test.py illustrates the most trivial graph you can run.
It contains just one side-effecting sink. Network returns a callable. Joe user
should think of it as a function. To push data through the network/pipe/graph,
call the function with an iterable argument.

    result = []
    net = Network(Sink(result.append))
    net(data)
    assert result == data

==================================================

Don't worry too much about the second test: it uses Map explicitly and you'll
almost always use it implicitly, as shown in the third test:

    result = []
    net = Network(f, Sink(result.append))
    net(data)
    assert result == list(map(f, data))

This shows that sticking a function (actually, anything that the framework
doesn't recognize as having some specific meaning) results in the function being
used as a map in the stream.

This should be the most common use case, so it's the strongest default of the
lot, with the lightest syntax: no syntax at all!

==================================================

Don't worry too much about the next test, which shows explicit use of Filter. Go
on to the next one, which demonstrates that `{predicate}` is the shorthand
notation for making filters.

    result = []
    net = Network({odd}, Sink(result.append))
    net(data)
    assert result == list(filter(odd, data))

==================================================

The next test shows that you don't have to write Sink either, as
`(side-effecting-fn,)` NB, note the trailing comma! it's a tuple. The comma
isn't ideal, but other options were used in more useful places.

==================================================

The next two tests show branches. The second one demonstrates that the shorthand
for branches is just sticking their components in list.

==================================================

The next test, `test_integration_1`:

    net = Network(f,
                  {a},
                  [g, {b}, (s.append,)],
                  h,
                  {c},
                  (t.append,))

sticks all this stuff together, so here we have implicit maps (f, g, h), filters
(a, b, c), sinks (s.append, t.append) and an implicit branch, all working
together.

==================================================

The next two tests (`fold_and_return` and `fold_with_initial_value`) show
explicit use of `Fold` (the new name for `reduce`), so don't bother with them,
as the implicit example is coming up shortly.

The one after that (`return_value_from_branch`) checks that `out` works
correctly in branches. Nothing new to be learned here about the interface.

==================================================

The good news is that the user never gets to see a future any more, and doesn't
even need to know that futures exist. It's all handled automatically behind the
interface. This means that if you want to use a future-sink (a name we can
probably not mention at all in the user manual), you must specify under what
name you want to retrieve its result. This is done with the `out` name factory.

Let's look at the salient line in `test_implicit_fold`:

    net = Network(out.total(sym_add))

When run, the network always returns a namespace. The `out.total` will inject
the name `total` into that namespace, binding it to the result of folding
(reducing) the stream with the argument to `out.total`, in this case `sym_add`.

==================================================

The next test shows that you can provide an initial value for the fold by
supplying a second argument to `out.<some-name>`.

    net = Network(out.total(sym_add))
    net = Network(out.total(sym_add, 99))

==================================================

`out.some_name` requires a value-returning-sink as its argument. As discussed
above, if you supply a function (maybe with a default value) it gets interpreted
as a fold by default.

But it's possible not to call `out.some_name` at all, in which case it will
collect the whole stream into a list. This is what
`test_implicit_collect_into_list` demonstrates:

    net = Network(out.everything)
    assert net(data).everything == list(data)

==================================================

The next new feature is shown in `test_get_implicit_map`:

    net = Network(get.A, out.B)
    assert net(data, A=f).B == list(map(f, data))

Observe the `get.A` in the network. This places a slot with the name `A` in the
network. The actual contents of the slot must be supplied before the network can
be run. The most obvious way of doing this is to supply a keyword argument with
the specified name (`A` in this case) when the network is run.

In this case, we supply a plain function, so it will be interpreted implicitly
as a map, but any other valid network component (implicit or explicit) should work.

This is a *HUGE* step forward in terms of capability WRT the old dataflow. This
is one of the features of the new framework which make components much more
reusable.

==================================================

After a bunch of tests exercising various combinations of features we have
already met, we get to `test_flat_map`:

    data = range(4)
    f = range
    net = Network(FlatMap(f), out.X)
    assert net(data).X == list(chain(*map(f, data)))

Note that `f` is a function which returns iterables. `FlatMap` feeds the
incoming stream elements into the function, and sends out the elements in the
resulting iterables, one by one.

As mentioned earlier, an obvious use case is to send filenames into the stream,
and get all the events in all those files in one long stream.

==================================================

The next huge step forward WRT the old dataflow is `OpenPipe`. In dataflow every
pipe had to be capped with a sink before it was usable. `OpenPipe` enables the
use of sinkless pipes, by turning them into functions.

    pipe_fn = OpenPipe(f,g).fn()
    assert pipe_fn(6) == (g(f(6)),)

Here we create an OpenPipe containing two plain functions (f and g) which will
be implicitly turned into maps. Then we use the `.fn()` method of `OpenPipe` to
create a function which sends its argument through those two maps and returns
the result.

In this case we placed maps in the pipe, which, as the name suggest perform a
1-to-1 mapping of inputs to outputs. But the pipeline can contain a filters and
FlatMaps. Consequently, in general, this function could return an arbitrary
number of values for each input. That is why the returned value is a 1-tuple.

In the case of maps, the tuple-wrapping is annoying, but it's unavoidable
because of the possibility of non-maps, as shown in the next two tests:

    f = odd
    pipe_fn = OpenPipe({f}).fn()
    assert pipe_fn(3) == (3,)
    assert pipe_fn(4) == ()

    f = range
    pipe_fn = OpenPipe(FlatMap(f)).fn()
    assert pipe_fn(3) == (0,1,2)
    assert pipe_fn(5) == (0,1,2,3,4)

In both cases, a different number of values is returned, depending on the input.

==================================================

`test_open_pipe_as_component` shows that, if you want to use an open pipe as a
component in another pipe, you need to use its `.pipe()` method to get it to
behave sensibly.

This is something that could be made to work by default. But that's a detail we
can deal with later on.

==================================================

Please remember that item picking (trivial) and item setting (trickier) are not
implemented yet, mainly because it's not clear how to do this in a general way
in the context of non-maps (filter, flat-map, ...)

Apart from that, is there anything else missing that would be needed to
implement the IC cities?
